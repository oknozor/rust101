<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust 101</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="ferris.css">
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="préambule.html">Preambule</a></li><li><a href="ch00_introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li><a href="ch01_paradigme.html"><strong aria-hidden="true">1.1.</strong> Paradigme</a></li><li><a href="ch02_safe_and_fast.html"><strong aria-hidden="true">1.2.</strong> Rapide et sûr</a></li><li><a href="ch03_borrow.html"><strong aria-hidden="true">1.3.</strong> Emprunt</a></li><li><a href="ch04_ownership.html"><strong aria-hidden="true">1.4.</strong> Propriété</a></li></ol></li><li><a href="ch05_intro_part2.html"><strong aria-hidden="true">2.</strong> Dans la vrai vie</a></li><li><ol class="section"><li><a href="ch06_ecosysteme.html"><strong aria-hidden="true">2.1.</strong> Ecosystème</a></li><li><a href="ch07_craft.html"><strong aria-hidden="true">2.2.</strong> Software Craft</a></li><li><a href="ch08_examples.html"><strong aria-hidden="true">2.3.</strong> Exemples</a></li><li><a href="ch09_conclusion.html"><strong aria-hidden="true">2.4.</strong> Conclusion</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust 101</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#preambule" id="preambule">Preambule</a></h1>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<h2><a class="header" href="#un-peu-dhistoire" id="un-peu-dhistoire">Un peu d'histoire</a></h2>
<p>Graydon Hoare developpeur sur gcc, swiftc, clang, llvm, commence à travailler sur rust sur son temps libre en 2006. 
En 2009 Mozilla commence à participer au projet et révèle officiellement le language en 2010. En 2011 le compilateur auto-hébergé (précédement en OCaml) est compilé avec succès pour la première fois. La première version stable de Rust est publiée en 2015.</p>
<p>En 2016 les première ligne de Rust son ajoutées à la version 48 de Firefox.</p>
<p>En 2018 un bug vieux de plus de 15 ans est corrigé suite à l'introduction de Rust dans le moteur de Firefox, il aura fallu plus de 10 ans de développement pour en arriver là. </p>
<h2><a class="header" href="#rust-pourquoi-faire-" id="rust-pourquoi-faire-">Rust pourquoi faire ?</a></h2>
<p>Le language se définit lui même sur son site officiel en mettant l'accent sur les points suivant :</p>
<ul>
<li>Performance : <em>&quot;fast and memory efficient&quot;</em> </li>
<li>Reliability : <em>&quot;memory safety and thread safety&quot;</em> </li>
<li>Productivity : <em>&quot;great documentation, friendly compiler...etc&quot;</em></li>
</ul>
<p>Si on traduit tout ça en bon français voilà ce que ça donne : </p>
<ul>
<li>Des performances comparable à C</li>
<li>Pas de bug au runtime (dangling pointer, wild pointer, memory leak...etc)</li>
<li>Pas de situation de competition dans les contextes concurrents/multitaches</li>
<li>Un écosystème à l'état de l'art</li>
</ul>
<h2><a class="header" href="#quelques-usage-emblématiques" id="quelques-usage-emblématiques">Quelques usage emblématiques</a></h2>
<ul>
<li>Firefox</li>
<li><a href="https://github.com/servo/servo">Servo</a></li>
<li><a href="https://github.com/libra/libra">Libra</a></li>
<li>Npm </li>
<li>Webassembly</li>
<li>Yelp</li>
<li><a href="https://github.com/sozu-proxy/sozu">Sozu</a></li>
<li><a href="https://github.com/xi-editor/xi-editor">Xi</a></li>
<li><a href="https://www.redox-os.org/">Redox</a></li>
</ul>
<p>Et bientôt Microsoft :) </p>
<h1><a class="header" href="#rust-un-language-mutli-paradigme" id="rust-un-language-mutli-paradigme">Rust, un language mutli-paradigme</a></h1>
<p>Un des gros avantages du language, et également un des point les plus déroutant pour les nouveaux arrivant, c'est le caractère multi-paradigme de Rust.</p>
<p>Mais qu'est ce qu'on veut dire par là au juste ? </p>
<p>En fait Rust s'inspire des géants qui ont fait leurs preuves, de ce fait il offre une large pallette de styles de programmation : </p>
<h2><a class="header" href="#programation-fonctionnelle" id="programation-fonctionnelle">Programation Fonctionnelle</a></h2>
<p>Rust permet de s'adonner au joies des monades et des closures ...etc</p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {
let a = [1, 2, 3];

let double: Vec&lt;i32&gt; = a.iter()
    .map(|&amp;x| x * 2)
    .collect();

println!(&quot;{:?}&quot;, double);
# }
</code></pre></pre>
<h2><a class="header" href="#pattern-matching" id="pattern-matching">Pattern matching</a></h2>
<p>Pour les développeurs qui connaissent Haskell, le concept sera relativement facile à aborder. Pour les autres c'est l'occasion de découvrir une des fonctionnalité les plus pratique de du language.</p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {
    pub enum Message {
        Greeting(String),
        Other
    }

    let salut_michel = Message::Greeting(&quot;michel&quot;.to_owned());

    match salut_michel {
        Message::Greeting(prenom)    =&gt; println!(&quot;Salut {}&quot;, prenom),
        Other(String) =&gt; println!(&quot;Message inconnue&quot;),
    }
# }
</code></pre></pre>
<h2><a class="header" href="#inférence-de-type" id="inférence-de-type">Inférence de type</a></h2>
<p>En rust les types sont statiques mais optionnels lorsque le compilateur parvient à les inférerers.</p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {
    let x: i32 = 42;
    let y = x + 9;

    println!(&quot;bienvenue dans la zone {}&quot;, y);
# }
</code></pre></pre>
<h2><a class="header" href="#orienté-objet" id="orienté-objet">Orienté objet</a></h2>
<p>Dans une certaine mesure Rust permet de faire de la POO, attention cependant les concepts sont totalement différent de ce dont vous avez probablement l'habitude avec Java. 
Il est impossible en rust de mélanger data et comportement, il n'y a donc pas d'héritage possible mais un système de trait (comparable au interface Java). 
Déroutant au premier abord on en découvre vite l'énorme potentiel.</p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {
    #[derive(Debug, PartialEq)]
    struct TabletteChocolat {
        type_choco: TypeChoco, 
    }

    #[derive(Debug, PartialEq)]
    enum TypeChoco {
        Noir,
        Blanc,
        Lait,
    }

    impl TabletteChocolat {
        fn new(type_choco: TypeChoco) -&gt; Self {
            TabletteChocolat {
                type_choco,
            }
        }
    }

    let choco_de_mamie = TabletteChocolat::new(TypeChoco::Noir);
    let choco_de_kevin = TabletteChocolat::new(TypeChoco::Lait);

    assert_eq!(choco_de_kevin, choco_de_kevin); 
# println!(&quot;Ok!&quot;);
# }
</code></pre></pre>
<h2><a class="header" href="#zero-cost-abstraction" id="zero-cost-abstraction">Zero cost abstraction</a></h2>
<p>Tout ce sucre syntaxique est absolument gratuit en terme de performance, c'est la toute la beauté de Rust: Une expression lambda et son équivalent en boucle procédurale seront optimisé de la même façon en bout de compilation. </p>
<p>Grâce au système de <em>lifetime</em> et au <em>borrow checker</em> sur lesquels on reviendra plus tard, Rust n'a pas besoin de GC.</p>
<h1><a class="header" href="#rapide-et-sûr" id="rapide-et-sûr">Rapide et sûr</a></h1>
<p>Au départ rust est un language de programmation système avec l'ambition de concurrencer C++, il a donc été créé avec les contraintes liées à ce domaine : Sécurité et rapidité. </p>
<p>Mais qu'est ce qu'on veut dire quand ont parle de language <em>memory safe</em> ?</p>
<p>D'après wikipdia : </p>
<blockquote>
<p><em>Memory safety is the state of being protected from various software bugs and security vulnerabilities when dealing with memory access, such as buffer overflows and dangling pointers. For example, Java is said to be memory-safe because its runtime error detection checks array bounds and pointer dereferences.</em></p>
</blockquote>
<p>Les amateurs de C doivent certainement comprendre de quoi on parle ici. 
En C on peut faire a peu près ce qu'on veut, si on introduit un bug ce faisant on aura le droit à une jolie <em>Segmetation fault</em> sans plus d'information, il ne nous reste plus que GDB pour nous en sortir, pire, on ne verra peut être pas le bug tout de suite.
C'est ce qui rend C aussi puissant mais également si difficile à maitriser.</p>
<p>En revanche Java est dit <em>memory safe</em> car un certain nombre d'erreurs prédéfinies peuvent advenir au runtime et on aura bien souvent une indication précise sur l'origine du problème.</p>
<p>Rust est également un language <em>memory safe</em>, mais il pousse le concept un peu plus loin : l'énorme différence avec ce qu'on connaissait jusque là, c'est que les erreurs de mémoires sont vérifiées à la compilation pas au runtime. Comme le dit un vieux proverbe rustaceen :</p>
<blockquote>
<p><em>&quot;The safest program is the program that doesn't compile&quot;</em></p>
</blockquote>
<p>Pour en arriver là Rust utilise deux concepts qui vous sont probablement étrangés : le <em>borrow checker</em>, et les l'<em>ownership</em></p>
<h1><a class="header" href="#emprunt-propriété-et-durée-de-vie" id="emprunt-propriété-et-durée-de-vie">Emprunt, propriété et durée de vie</a></h1>
<p>On commence doucement à entrer dans le vif du sujet. Les concept qu'on va évoquer ici sont propre à Rust et indubidablement difficile à appréhender.</p>
<p>Toute la force de Rust réside dans ces trois concepts :</p>
<ul>
<li>L'emprunt (<em>Borrow checking</em>)</li>
<li>La propriété (<em>Ownership</em>)</li>
<li>Les durée de vie (<em>Lifetimes</em>)</li>
</ul>
<p>C'est grâce à eux que rust se passe de Ramasse miette sans pour autant nous contraindre à gérer les allocations mémoire de façon manuelle. </p>
<h2><a class="header" href="#ownership" id="ownership">Ownership</a></h2>
<p>La propriété est un concept simple à comprendre et pourtant difficile à maitriser en pratique. 
Commençons par énnoncer les trois règles qui régissent ce concept: </p>
<ul>
<li>Toute valeur en Rust a une variable appelé sont possesseur (<em>owner</em>).</li>
<li>Il ne peut y avoir qu'un seul possesseur à la fois pour une valeur.</li>
<li>Quand le possesseur sort du contexte (<em>scope</em>), la valeur est éffacée.</li>
</ul>
<h3><a class="header" href="#heap-vs-stack-copy-vs-clone" id="heap-vs-stack-copy-vs-clone">Heap vs. Stack, Copy vs. Clone</a></h3>
<p>Par défaut les primitives sont stockées sur la pile (<em>stack</em>), elle sont peu couteuse en mémoire et donc copié automatiquement lorsque l'ont cré un nouveau binding.</p>
<pre><pre class="playpen"><code class="language-rust"># fn main() {
    let x = 51; 
    let y = x;

    println!(&quot;x: {}, y: {}&quot;, x, y);
# }
</code></pre></pre>
<p>Au contraire les structures plus complexes comme <code>String</code> ici sont stockées dans le tas (<em>heap</em>).
Si on reprend les trois règles de la propriété vu plus haut on peut deviner se qui va se passer ici.</p>
<pre><code class="language-rust does_not_compile ignore"># #[allow(dead_code)]
# fn main() {
    let s1 = String::from(&quot;Arrrrrggh!&quot;);
    let s2 = s1; 

    println!(&quot;{}&quot;, s1);
# }
</code></pre>
<p>Ça ne compile pas, le compilateur nous apprend que la variable à été déplacé avant usage.
En effet <strong>une valeur ne peut avoir qu'un possesseur à la fois</strong>, le binding de <code>s1</code> à été supprimer avant qu'on l'appelle avec la macro <code>println</code>. </p>
<pre><code>error[E0382]: borrow of moved value: `s1`
 --&gt; main.rs:6:20
  |
3 |     let s1 = String::from(&quot;Arrrrrggh!&quot;);
  |         -- move occurs because `s1` has type `std::string::String`, which does not implement the `Copy` trait
4 |     let s2 = s1;
  |              -- value moved here
5 |
6 |     println!(&quot;{}&quot;, s1);
  |                    ^^ value borrowed here after move
</code></pre>
<p>Donc, contrairement au primitive, les structures stockées sur le tas ne sont pas copiées automatiquement, voilà comment on peut s'en sortir : </p>
<pre><pre class="playpen"><code class="language-rust"># #[allow(dead_code)]
# fn main() {
    let s1 = String::from(&quot;Yeah!&quot;);
    let s2 = s1.clone(); 

    println!(&quot;{}&quot;, s1);
# }
</code></pre></pre>
<p>Ici au lieu de déplacer la référence on fait une copie complète de <code>s1</code>, pas seulement de la référence vers les données stocké dans le tas, mais de l'entièreté de la variable. C'est une solution un peu radicale et heureusement il est possible de faire autrement. </p>
<h1><a class="header" href="#borrow-cheking" id="borrow-cheking">Borrow Cheking</a></h1>
<h2><a class="header" href="#les-références" id="les-références">Les références</a></h2>
<p>On à vu précédement que les règles de propriété pouvaient être très contraignantes, prennons un exemple simple :</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let raffarinade = String::from(&quot;Je vous recommande la positive attitude.&quot;);
    let (s2, len) = calculate_string_len(raffarinade);

    println!(&quot;Cette raffarinade: \&quot;{}\&quot;, contient {} caractères&quot;, s2, len);
}

fn calculate_string_len(s: String) -&gt; (String, usize) {
    let len = s.len();
    (s.clone(), len)
} 
</code></pre></pre>
<p>Pour effectuer une opération aussi simple que retourner la longueur d'une chaine de caractères on est obligé de retourner un tuple avec une copie de la chaine.
Heureusement on peut s'affranchir de tout ces salamalèques avec les références :</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let raffarinade = String::from(&quot;La faiblesse de vocabulaire signifie la faiblesse de penser.&quot;);
    let len = calculate_string_len(&amp;raffarinade);

    println!(&quot;Cette raffarinade: \&quot;{}\&quot;, contient {} caractères&quot;, raffarinade, len);
}

fn calculate_string_len(s: &amp;String) -&gt; usize {
    s.len()
} 
</code></pre></pre>
<h2><a class="header" href="#lecteurécrivains" id="lecteurécrivains">Lecteur/écrivains</a></h2>
<p>En fait l'usage des références nous permet de manipuler une variable sans en acquérir la propriété. Mais que ce passe il si on veut modifier le contenue d'une référence ? </p>
<pre><code class="language-rust does_not_compile ignore">fn main() {
    let mut s = String::from(&quot;Jean&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(&quot;-Michel&quot;);
}
</code></pre>
<p>Pour manipuler le contenue de la référence il faut pouvoir le <em>déréférencer</em>, et pour cela il faut avoir la permission d'en acquérir la propriété. </p>
<pre><code>error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- help: consider changing this to be a mutable reference: `&amp;mut std::string::String`
8 |     some_string.push_str(&quot;-Michel&quot;);
  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
</code></pre>
<p>Si on suis les indications du compilateur voilà ce que ça donne :</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;Jean&quot;);

    change(&amp;mut s);
    println!(&quot;{}&quot;, s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;-Michel&quot;);
}
</code></pre></pre>
<p>Il nous reste une dernière règle à comprendre pour saisir l'entièreté du concept. Comme dans un contexte de programmation concurente, Rust nous force en permanence à appliquer la politique lecteur/écrivains : </p>
<pre><code class="language-rust does_not_compile ignore">let mut s = String::from(&quot;Damnit!&quot;);

let r1 = &amp;mut s;
let r2 = &amp;mut s;

println!(&quot;{}, {}&quot;, r1, r2);
</code></pre>
<pre><code>   Compiling playground v0.0.1 (/playground)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:7:10
  |
6 | let r1 = &amp;mut s;
  |          ------ first mutable borrow occurs here
7 | let r2 = &amp;mut s;
  |          ^^^^^^ second mutable borrow occurs here
8 | 
9 | println!(&quot;{}, {}&quot;, r1, r2);
  |                    -- first borrow later used here
</code></pre>
<p>Comme pour les bases de données et la synchronisation de ressources dans un contexte de programmation concurrente Rust force l'utilisation du modèle lecteur/écrivaint. Il est donc possible d'avoir autant de référence immutable vers une valeur qu'on le souhaite mais une et une seule référence mutable.</p>
<h2><a class="header" href="#validité" id="validité">Validité</a></h2>
<pre><code class="language-rust does_not_compile ignore">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
</code></pre>
<p>Ici on voit bien que la variable <code>s</code> va être supprimée par le <em>borrow checker</em> après l'éxécution de <code>dangle()</code>. La référence <code>&amp;s</code> n'est donc pas valide, ça ne compile pas.</p>
<pre><code>error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ help: consider giving it a 'static lifetime: `&amp;'static`
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
</code></pre>
<p>On ne va pas s'attarder sur le concept de de validité pour l'instant, sachez simplement qu'il est possible d'indiquer au compilateur de façon explicite la durée de validité d'une référence avec les <em>lifetime</em>.</p>
<h2><a class="header" href="#résumé" id="résumé">Résumé</a></h2>
<p>Comme la propriété, l'emprunt est régi par des règle simples :</p>
<ul>
<li>À tout moment, il est possible d'avoir soit <em>une et une seule</em> référence mutable ou n'importe quel nombre de référence immutable.</li>
<li>Une référence doit toujours être valide.</li>
</ul>
<h1><a class="header" href="#dans-la-vrai-vie" id="dans-la-vrai-vie">Dans la vrai vie</a></h1>
<p>Jusqu'à maintenant on s'est éfforcé de comprendre ce qui rendait Rust si particulié d'un point de vu théorique : multi-paradigme, <em>memory safe</em>, <em>borrow checking</em>, <em>ownership</em> ...etc</p>
<p>Tout cela peut être bien décourageant au premier abord. Rust n'est en effet pas facile d'accès mais fort heureusement les qualités du language ne s'arrête pas à la prouesse technique et théorique.</p>
<blockquote>
<p><em>Rust a une excellente documentation, un compilateur amical avec des messages d'erreur utiles et un outillage de premier ordre</em></p>
</blockquote>
<p>Ça c'est ce que nous dit le site officiel du langague mais qu'en est-il dans les faits ?</p>
<p>C'est ce qu'on va voir maintenant en s'interressant au points suivant :</p>
<ul>
<li>Écosystème</li>
<li>Software craft</li>
<li>Quelque exemples</li>
</ul>
<h1><a class="header" href="#ecosystème" id="ecosystème">Ecosystème</a></h1>
<p>Pour comprendre ce qui fait l'intérêt d'un language de programation, ses qualités techniques ne sont qu'une partie de l'équation. On peut penser à javascript qui dispose d'un écosystème fourni, de nombreux frameworks, une quantité plétorique de librairies et d'outils, plusieurs package managers, des extentions comme flow ou typescripts ...ect.</p>
<p>L'écosystème de Rust, si il manque encore de maturité, à pris une direction intéressante :</p>
<ul>
<li><a href="https://www.rust-lang.org/community">Une communauté ouverte</a></li>
<li>Un gestionnaire de paquet dédié</li>
<li>Une génération de documentation simplifié</li>
</ul>
<h2><a class="header" href="#communauté" id="communauté">Communauté</a></h2>
<p>Rust à été créé dans les bureau de Mozilla, venant du monde de l'opensource, le parti pris est de ne pas s'appuyer sur sa communauté plus que sur les entreprises qui supportent le langage. Même si cela peut sembler annecdotique, cette vision est au coeur de Rust et il serait dommage de passer à côté.</p>
<p>Si vous êtes débutant en Rust, il est fortement recommander de jetter un oeil au <a href="https://www.rust-lang.org/policies/code-of-conduct">code de conduite de rust</a> et d'aller faire un tour sur les différents média de la communauté : discord, gitter, forum, mailing-list ...etc. N'hésiter pas à y poser des questions, même si elle vous semble bêtes, les utilisateurs expérimentés du langage vous répondrons à coup sûr.</p>
<p>En plus de cet accueil chaleureux c'est sur les sites de la communauté que la volonté universaliste de Rust est la plus visible. Si, jusque ici vous pensez toujours que Rust est un langage destiné à la programation système, voici quelque ressources issues de la communauté pour vous convaincre du contraire:</p>
<ul>
<li><a href="https://www.arewewebyet.org/">Are we web yet?</a></li>
<li><a href="http://arewegameyet.com/">Are we game yet?</a></li>
<li><a href="https://areweideyet.com/">Are we (I)DE yet?</a></li>
<li><a href="https://areweguiyet.com/newsfeed/2019-01-13_rust2019.html">Are we GUI yet?</a></li>
<li><a href="https://www.arewelearningyet.com/">Are we learning yet?</a></li>
<li><a href="https://areweasyncyet.rs">Are we async yet?</a></li>
<li><a href="https://areweaudioyet.com/">Are we audio yet?</a></li>
<li>Un peu moins sérieux : <a href="https://www.reddit.com/r/rustjerk/">The Rust Evangelism Strike Force</a></li>
</ul>
<p>Comme vous pouvez le constater la communauté des Rustacées est en marche pour conquérir tout les domaines de la programmation.</p>
<h2><a class="header" href="#package-manager" id="package-manager">Package manager</a></h2>
<p>Dans la plupart des autres écosystèmes les gestionnaires de paquets sont découplés du langage en lui même. On peut penser à l'antagonisme entre Maven et Graddle pour les javaiste, Npm et Yarn pour javascript.</p>
<p>Rust n'a (pour l'instant) qu'un seul gestionnaire de paquet et c'est un outil officiel : <a href="https://doc.rust-lang.org/cargo/">Cargo</a>.
Pour décrire les dépendances d'un projet, Cargo utilise <a href="https://github.com/toml-lang/toml">Toml</a> : Tom's Obvious, Minimal Language.</p>
<p>Ce petit language simple et efficace permet de configurer un projet rapidement et il est peu probable que vous rencontrier jamais de <a href="https://stephencoakley.com/2019/04/24/how-rust-solved-dependency-hell">conflits de dépendance</a>.</p>
<p>Pour vous procurer ou uploader des librairies et consulter leur documentation (appellées crate en rust) rendez vous sur <a href="https://www.crates.io/">crate.io</a> il est également possible d'utiliser un simple dépôt git comme source d'une dépendance. Depuis peut cargo permet d'utiliser des <a href="https://blog.cloudsmith.io/2019/05/01/worlds-first-private-cargo-registry/">registres privée</a>.</p>
<h2><a class="header" href="#documentation" id="documentation">Documentation</a></h2>
<p>Quand on s'attèle à l'apprentissage d'un nouveau language, on se procure un ouvrage de référence, on consulte des articles de blog sur tel ou tel point que l'ont souhaite approfondir. Hé bien si vous avez décidez de vous y mettre, inutile de sortir votre portefeuille pour l'instant. Le site officiel du langage contient tout ce dont vous aurez besoin our vous y mettre.</p>
<p>Si vous ête amateur de théorie et que vous aimez aller au fond des choses <a href="https://doc.rust-lang.org/book/index.html">The Rust Programming Language</a> est l'ouvrage de référence, si au contraire vous préférez apprendre en pratiquant <a href="https://doc.rust-lang.org/stable/rust-by-example/">Rust by example</a> est fait pour vous. De manière général les ressources listées sur le <a href="https://www.rust-lang.org/learn">site officiel</a> du langage sont de très bonne qualité</p>
<h1><a class="header" href="#software-craft" id="software-craft">Software Craft</a></h1>
<p>Évoquer le <a href="http://manifesto.softwarecraftsmanship.org/">software craft</a> ici n'est peut être pas complètement adapté mais il serait difficile de ne pas y référer tant Rust s'éforce d'encourager certaines pratiques qui gravitent autour du craft et des méthodes agiles: TDD, Documentation as code, Doc test, CI-CD ...etc.</p>
<h2><a class="header" href="#Écrire-de-la-documentation" id="Écrire-de-la-documentation">Écrire de la documentation</a></h2>
<p>Une fois de plus, c'est la simplicité et l'efficacité qui prime. En rust pour commenter du code on utilise comme en C deus slash, pour documenter une librairie ou un programme on utilise markdown échappé par <code>///</code> en début de ligne. Voilà c'est tout, il n'y a presque rien d'autre à savoir.</p>
<p>La documentation du projet peut ensuite être générer avec <code>cargo doc</code> et consultée hors ligne avec <code>cargo doc --open</code>.</p>
<h2><a class="header" href="#ttd--rust" id="ttd--rust">TTD &amp; Rust</a></h2>
<p>Pour <a href="https://doc.rust-lang.org/book/ch11-01-writing-tests.html">écrire des tests en rust</a>, rien de plus simple, on utilise l'annotation <code>#[test]</code> :</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn should_add_pastis() {
        assert_eq!(51 + 51, 102);
    }
}
#}</code></pre></pre>
<p>Si vous avez l'habitude d'écrire des tests, vous allez rapidement remarquer qu'en Rust on écrit bien souvent les tests unitaires directement à côté du code fonctionnel. Cette pratique à l'avantage de documenter le code fonctionnel directement dans le même fichier. Lorsque le programe est compilé les tests sont compilé dans un exécutable séparé et ne viendrons pas polluer notre code de production.</p>
<h2><a class="header" href="#benchmarks" id="benchmarks">Benchmarks</a></h2>
<p>En plus des tests rust permet via l'anotation <code>#bench</code> de tester les performance d'une section de code, on peut ainsi tracer facilement les régression/amélioration de performance dans une base de code.</p>
<h2><a class="header" href="#doc-test" id="doc-test">Doc test</a></h2>
<p>En Rust il est possible d'écrire <a href="https://doc.rust-lang.org/rust-by-example/testing/doc_testing.html">des tests directement dans la documentation</a>.
Ces tests vont être exécuté à la compilation et  permettent de s'assurer que notre documentation est toujours à jours avec le code fonctionnel. Merveilleux non ?</p>
<h1><a class="header" href="#exemples" id="exemples">Exemples</a></h1>
<h2><a class="header" href="#une-librairie--musicbrainz_rs" id="une-librairie--musicbrainz_rs">Une librairie : musicbrainz_rs</a></h2>
<h2><a class="header" href="#un-cli--" id="un-cli--">Un cli : ??</a></h2>
<h2><a class="header" href="#une-appliaction-native--ilumination" id="une-appliaction-native--ilumination">Une appliaction native : ilumination</a></h2>
<h2><a class="header" href="#une-application-web--unicool" id="une-application-web--unicool">Une application web : unicool</a></h2>
<h1><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="ferris.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
